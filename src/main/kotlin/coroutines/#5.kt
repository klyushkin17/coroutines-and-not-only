package org.example.coroutines

/*
///Channels///
Channel -- структура, позволяющая передавать данные между корутинами.
.send() - метод для отправки значений в канал
.receive() - метод для получения значекний из канала

Данные функции являются suspend, соответственно могут быть вызваны только из корутин.
Но есть и другие методы. которые не являются suspend (trySend(), tryReceive())
val result: ChannelResult<*> = channel.trySend(...)
when {
    result.isSuccess -> // Получилось отправить данные
    result.isFailure -> // Канал не может принять данные
    result.isClosed -> // Канал закрыт на отправку
}

val result: ChannelResult<Data> = channel.tryReceive(...)
when {
    result.isSuccess -> result.getOrThrow()
    result.isFailure -> // Канал не может выдать данные
    result.isClosed -> // Канал закрыт на получение данных
}

По умолчанию канал работает до того момента, пока не будте вызвана функция .close()
Так же каналы расчитаны на работу с несколькими корутинами, из-за этого он может иметь несколько отправителей
и несколько получателей
Канал может приводить к приостановке корутины, пока он отправляет или получает значение, поэтому важно остановить
канал, когда он уже большене нужен

По умолчанию у каналов не буфера, соответственно при отправе send(), если нет получателя, канал будет останавлиться.
Чтобы этого избежать можно задать каналу параметр capacity, который определяет размер буфера:
-rendezvous: без буфера
-conflated: Размер буфера = 1. Хранит только последнее полученное значение, а предыдущее удаляется
-buffered: Задает стандартный размер буфера, который определен в свойствах окружения(по умолчанию это 64)
-unlimited: Максимально возможный размер буфера

Так же при создании канала можно управлять политикой поведения .send()
suspend: корутина будет приостановлена, если принять значение сейчас нкому, а буфер переполнен или отсутствует.
drop_oldest: при переполнении буфера удаляется элемент по принципу очереди
drop_latest: при переполнении буфера удаляется элемент по принципу стека

.produce() служит для передачи бесконеченгого или конечного количества значений
val channel: ReceiveChannel<Int> =
    scope.produce {
        val x = 1
        while (true) {
            send(x++)
        }
    }

scope.launch {
    val data = channel.receive()
}

.actor() используется для получения значений извне
val actor: SendChannel<Any> = scope.actor {
    val data = receive()
    writeStringToFile(date)
}

scope.launch {
    actor.send(data)
}

fun main() {

}*/
