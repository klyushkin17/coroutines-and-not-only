package org.example.coroutines

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow

/*
///Flow///
Flow - асинхронный поток данных, который последовательно выдает значения и завершается
успешно или с ошибкой

Холодный поток - выдает значения только при запуске (Flow)
Горячий поток - начинает работать сразу при создании (StateFlow, SharedFlow)


Создание flow
Для создания оператора с уже известными значениями можно использовать flowOf
Если же необходимо самостоятельно вставлять значения нужно уже использовать оператор flow и
пользоваться функцией emit()

..Операторы..
Промежуточные опрераторы настраивают цепочку для будующего выполнения
combine(): объединяет два потока в один, после применения к их элементам функции преобразования

drop(): исключает из начала потока определенное количество значений и возвращает полученный поток

filter(): фильтрует поток, оставляя те элементы, которые соответствуют условию

filterNot(): фильтрует поток, оставляя те элементы, которые НЕ соответствуют условию

filterNotNull(): фильтрует поток, удаляя все элементы, которые равны null

map(): применяет к элементам потока фукцию преобразования

onEach(): применяет к элементам потока определенную функцию перед тем, как они будут переданы в возвращаемый поток

take(): выбирает из потока определенное количество элементов

transform(): применяет к элементам потока функцию преобразования

zip(): из двух потоков создает один, применяя к их элементам функцию преобразования

Пример создания собственного оператора, который будет выделать только уникальные значения*/

fun <T> Flow<T>.unique(): Flow<T> {
    return flow {
        var lastValue: Any? = NoValue
        collect { value: T ->
            if (lastValue != value) {
                lastValue = value
                emit(value)
            }
        }
    }
}

private object NoValue

/*
Терминальные операторы
Все терминальные операторы - это suspend функции
collect(): получает из потока переданные значения

toList(): преобразует поток значений в коллекцию List

toSet(): преобразует поток значений в коллекцию Set

first() / firstOrNull(): получает первый объект из потока

last() / lastOrNull(): получает последний объект из потока

single() / singleOrNull(): ожидает получение одного объекта из потока

count(): получает количество элементов в потоке

reduce(): получает результат определенной операции над элементами потока

fold(): получает результат определенной операции над элементами потока,
в отличие от функции reduce() принимает начальное

scope.launch {
    flow<String> {}
        .filter {}
        .map {}
        .collect {}
}

ИЛИ

flow<String> {}
        .filter {}
        .map {}
        .launchIn(scope)

Так как все терминальные функции являются suspend, это значит, что после каждого emit()
будут вызываться терминальные функции. Чтобы сделать так, чтобы сначала вызвались все emit(),
а затем все терминальные функции можно использовать buffer()
flow.buffer(
    capacity = Channel.BUFFERED,
    onBufferOverflow = BufferOverflow.SUSPEND
)

Если необходимо поменять контекст выполнения flow, то для этого используется .flowOn()
flow {
    repeat(5) {
        emit(it)
    }
}.flowOn(Dispatchers.Default)

flowOn меняет контекст для всей цепочки до предыдущего вызова flowOn или до flowBuilder


Обработка ошибок
try {
    flow {...}
} catch (e: Exception) {
    //Обработка
}


SharedFlow - горячий, бесконечный поток данных. Работает всегда. Может содержать несколько
подписчиков. Не имеет контекста выполнения.
Mutable версии State и Shared Flow. Позволяют не только получать значения, но и вкидывать
туда новые значения

StateFlow - частный случай SharedFlow, который хранит всего одно значения и доставляет его всем
подписчикам. Новое значение будет отправлено только в том случа, если оно изменилось. Чаще
всего он используется для хранения состояния UI

*/
