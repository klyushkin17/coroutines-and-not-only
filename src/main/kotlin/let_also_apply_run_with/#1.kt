package let_also_apply_run_with

private val number: Int? = null

private var i = 0

fun main() {

    if (number != null) {        //Данный подход к проверке на null, не всегда сработает корректно. Это произойдет в случае, если
        val number2 = number + 1 //переменная, которая была проверена ан null, будет изменена другим потоком в процессе выполнения
    }                            //блока if. Поэтому kotlin, как null-безопасный язык не даст провести подобную проверку

    number?.let {               //let блок позволяет решить эту проблему. Сначала переменная проверяется на null с помощью ?, а
        val number2 = it + 1    //потом вызывается метод let, который внутрь себя передает объект, который не измениться в том
    }                           //случае, если переменная будет изменена другим потоком

    val x = number?.let {       //let возвращает последнюю строку блока
        val number2 = it + 1
        number2
    } ?: 3 // Можно использовать элвис-оператор, если необходимо передать переменной значение в случае null

    fun getSquaredI() = (i * i).also{ //also - практически такой же оператор, как и let, но при этом он возвращает не последнюю строку кода
        i++                           //, сам объект для которого был вызван also
    }

    val intent = Intent().apply {  //apply - удобное свойство для модификации объектов, так как позволяет обращаться к методам класса сразу
        putExtra("","")      //, не указывая it, так как уже передает в блок this
        putExtra("","")
    }

    val intent2 = Intent().run {  //все то же самое, только возвращает последнюю строчку кода
        putExtra("","")
        putExtra("","")
        this
    }

    val i = with(Intent()) {      //делает все абсолютно то же самое, что и run, но при этом принимает объект в качестве аргумента
        putExtra("","")
        putExtra("","")
        this
    }
}

class Intent() {
    fun putExtra(a: String, b: String) {
        TODO()
    }
}
